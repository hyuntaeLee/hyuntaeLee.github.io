---
layout: post
title: 【0x01】 Character Device Drivers
subtitle: Review
categories: CVE_Linux
banner:
  image: https://github.com/hyuntaeLee/hyuntaeLee.github.io/assets/97331148/10f87e65-fde3-4a2d-9af9-7d7b442f3ad7
tags: [linux, kernel, Review]
---

## Device Driver?

Device란 컴퓨터에 물려있는 여러 주변장치를 뜻한다.  

네트워크 어댑터, 오디오, 터미널, 키보드, 하드 디스크, 플린터 등이 Device에 해당하고, 이러한 디바이들을 컨트롤하기 위한 Device Driver가 존재한다.

`/dev/`아래에 들어있는 파일들은 Device Driver와 연결된 interface 역할을 하며(Device Driver interface), 이를 통해 응용 프로그램이 하드웨어오 독립적으로 디바이스에 접근할 수 있다.

<p align="center">
<img src="https://github.com/hyuntaeLee/hyuntaeLee.github.io/assets/97331148/b19d21d1-e4f5-42c9-9e79-dc384656d6c9" width = 500>
</p>

1. **실제 물리적 하드웨어(Real Device)**
    - 실제 컴퓨터 시스템에 연결된 다양한 물리적 하드웨어 장치들이 있습니다.

2. **디바이스 드라이버(Device Driver)**
    - 각 하드웨어 장치는 특정 규격과 인터페이스를 가지고 있습니다.
    - 개발자가 모든 하드웨어 규격에 맞춰 직접 구현하는 것은 비효율적이다.
        - 따라서 리눅스에서는 각 장치별로 해당 하드웨어를 제어할 수 있는 Device Driver를 제공한다.

3. **VFS(Virtual File System)**
    - 리눅스는 VFS라는 가상 파일 시스템 계층을 제공한다.
    - 이를 통해 모든 디바이스 드라이버가 `/dev` 디렉터리 아래에 파일로 표현된다.

4. **디바이스 파일 인터페이스**
    - 응용 프로그램은 `open()`, `read()`, `write()` 등의 시스템 호출을 통해 디바이스 파일에 접근할 수 있다.
    - 이렇게 함으로써 하드웨어와 독립적으로 디바이스를 제어할 수 있다.

5. **디바이스 파일 등록**
    - 모든 디바이스 파일은 고유한 번호(major, minor)와 이름을 가지고 있다.
    - 따라서 새로운 디바이스 드라이버를 제작하고 등록하려면, 고유한 번호와 이름을 할당받아야 한다.

Linux는 Device Driver와 VFS 계층을 통해 물리적 하드웨어와 응용 프로그램 사이의 추상화 계층을 제공합니다. 이를 통해 개발자는 효율적으로 다양한 하드웨어를 지원할 수 있다.

<p align="center">
<img src="https://github.com/hyuntaeLee/hyuntaeLee.github.io/assets/97331148/b4939a43-752e-4ea1-bf91-31db7fcc0688" width = 500>
</p>

사진으로 통해, 한눈에 Device Driver의 종류를 확인할수 있으며, 해당 Device Driver가 어떠한 Device를 위해 존재하는지 알수 있다.

## Character Device Drivers

<p align="center">
<img src="https://github.com/hyuntaeLee/hyuntaeLee.github.io/assets/97331148/ee7564af-c758-40bf-bdba-c9e54159d9cc" width = 500>
</p>

* **Character Device Drivers**는 유저 프로세스로부터 직접(**buffer cache**등을 사용하지 않고) 데이터를 읽고 쓰는 디바이스 드라이버이다.
    * ex) keyboard, Sound card, Printer 드라이버

* 그리고 **Block Device, Network Device** 드라이버가 있다.
    * 블록 디바이스 드라이버는 버퍼 캐시를 통한 임의 접근과 블록 단위로 입출력이 가능하다.
        * ex) 하드디스크

    * 네트워크 디바이스 드라이버는 네트워크 스택과 네트워크 하드웨어 사이에 위치해 데이터의 송수신을 담당한다.
        * ex) Ethernet, Network interface card

## struct file_operations

* **file_operations** 구조체는 **Character Device, Block Device** 드라이버와 일반 프로그램간의 통신을 위해 제공되는 인터페이스입니다.
    * read, write, open, release, unlocked_ioctl 등의 함수 포인터를 사용할 수 있다.
    * Network Device는 file_operations 구조체를 사용하지 않는다.
        * "include/linux/netdevice.h"파일의 "net_device" 구조체를 사용한다.

```c
struct file_operations {
	struct module *owner;
	loff_t (*llseek) (struct file *, loff_t, int);
	ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
	ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
	ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);
	ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);
	int (*iopoll)(struct kiocb *kiocb, struct io_comp_batch *,
			unsigned int flags);
	int (*iterate_shared) (struct file *, struct dir_context *);
	__poll_t (*poll) (struct file *, struct poll_table_struct *);
	long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
	long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
	int (*mmap) (struct file *, struct vm_area_struct *);
	unsigned long mmap_supported_flags;
	int (*open) (struct inode *, struct file *);
	int (*flush) (struct file *, fl_owner_t id);
	int (*release) (struct inode *, struct file *);
	int (*fsync) (struct file *, loff_t, loff_t, int datasync);
	int (*fasync) (int, struct file *, int);
	int (*lock) (struct file *, int, struct file_lock *);
	unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
	int (*check_flags)(int);
	int (*flock) (struct file *, int, struct file_lock *);
	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
	ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	void (*splice_eof)(struct file *file);
	int (*setlease)(struct file *, int, struct file_lock **, void **);
	long (*fallocate)(struct file *file, int mode, loff_t offset,
			  loff_t len);
	void (*show_fdinfo)(struct seq_file *m, struct file *f);
#ifndef CONFIG_MMU
	unsigned (*mmap_capabilities)(struct file *);
#endif
	ssize_t (*copy_file_range)(struct file *, loff_t, struct file *,
			loff_t, size_t, unsigned int);
	loff_t (*remap_file_range)(struct file *file_in, loff_t pos_in,
				   struct file *file_out, loff_t pos_out,
				   loff_t len, unsigned int remap_flags);
	int (*fadvise)(struct file *, loff_t, loff_t, int);
	int (*uring_cmd)(struct io_uring_cmd *ioucmd, unsigned int issue_flags);
	int (*uring_cmd_iopoll)(struct io_uring_cmd *, struct io_comp_batch *,
				unsigned int poll_flags);
} __randomize_layout;
```

* 예를 들어 다음과 같은 방법으로 디바이스 모듈에서 open()함수를 제공할 수 있다.
    * file_operations 구조체에 작성된 함수 포인터의 인자값을 이용하여 open 함수의 코드를 작성한다.
    
    * 작성한 함수의 명은 "struct file_operations" 형태로 선언된 구조체의 ".open" 필드에 함수의 주소(chardev_open)를 저장한다.

```c
static int chardev_open(struct inode *inode, struct file *file)
{
    printk("chardev_open");
    return 0;
}
struct file_operations chardev_fops = {
    .open    = chardev_open,
};
```

## Simple Char Device Driver 

<p align="center">
<img src="https://github.com/hyuntaeLee/hyuntaeLee.github.io/assets/97331148/0f1059ed-ea6c-49c5-8f2b-900f1aaf8f47" width = 500>
</p>



## reference
[https://jeongzero.oopy.io/c5c9c223-d17f-4bbc-b054-4d9fa1faffd1](https://jeongzero.oopy.io/c5c9c223-d17f-4bbc-b054-4d9fa1faffd1)

[https://pr0gr4m.tistory.com/entry/Linux-Kernel-5-Character-Device-Driver](https://pr0gr4m.tistory.com/entry/Linux-Kernel-5-Character-Device-Driver)

[https://www.lazenca.net/display/TEC/02.Character+Device+Drivers](https://www.lazenca.net/display/TEC/02.Character+Device+Drivers)

[https://butter-shower.tistory.com/29](https://butter-shower.tistory.com/29)

[https://linuxhint.com/basic-character-driver-linux/](https://linuxhint.com/basic-character-driver-linux/)